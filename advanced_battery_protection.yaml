# Advanced Battery Protection System for Home Assistant
# This provides comprehensive battery monitoring and protection

# Input helpers for configuration (add to configuration.yaml)
input_boolean:
  battery_protection_enabled:
    name: "Battery Protection Enabled"
    icon: mdi:shield-battery
    initial: true

input_number:
  battery_protection_threshold:
    name: "Protection Threshold (%)"
    min: 5          # MINIMUM value: Lowest threshold you can set (recommended: 5-10%)
    max: 50         # MAXIMUM value: Highest threshold you can set (recommended: 30-50%)
    step: 1         # STEP size: How much the value changes with each adjustment (1% increments)
    initial: 15     # INITIAL value: Default threshold when first created (your starting point)
    icon: mdi:battery-alert
    unit_of_measurement: "%"
    
    # HOW TO ADJUST THESE PARAMETERS:
    #
    # 1. MIN (minimum value):
    #    - Sets the lowest protection threshold you can configure
    #    - Recommended: 5-10% (prevents setting dangerously low thresholds)
    #    - Example: min: 5 means you can't set threshold below 5%
    #    - Safety consideration: Don't set below 5% to prevent battery damage
    #
    # 2. MAX (maximum value):
    #    - Sets the highest protection threshold you can configure  
    #    - Recommended: 30-50% (prevents over-conservative settings that limit power)
    #    - Example: max: 40 means you can't set threshold above 40%
    #    - Balance consideration: Higher max allows more conservative protection
    #
    # 3. STEP (increment size):
    #    - How much the slider/input changes with each adjustment
    #    - step: 1 = adjusts by 1% each time (fine control)
    #    - step: 5 = adjusts by 5% each time (coarse control) 
    #    - step: 0.5 = adjusts by 0.5% each time (very fine control)
    #    - Recommended: 1 for most users, 0.5 for precise tuning
    #
    # 4. INITIAL (starting value):
    #    - The default value when the input helper is first created
    #    - This becomes your baseline protection level
    #    - Recommended starting points:
    #      * Conservative users: 20-25%
    #      * Balanced users: 15% (current default)
    #      * Aggressive users: 10%
    #      * Emergency-only: 5%
    #
    # EXAMPLE CONFIGURATIONS:
    #
    # Conservative setup (protect batteries early):
    # min: 10, max: 40, step: 1, initial: 25
    #
    # Balanced setup (good protection vs power availability):
    # min: 5, max: 30, step: 1, initial: 15
    #
    # Aggressive setup (maximum power, minimal protection):
    # min: 5, max: 20, step: 1, initial: 8
    #
    # Fine-tuning setup (precise control):
    # min: 5, max: 30, step: 0.5, initial: 12.5
    #
    # Simple setup (basic 5% increments):
    # min: 10, max: 30, step: 5, initial: 20
    #
    # HOW THESE SETTINGS AFFECT THE USER INTERFACE:
    #
    # In Home Assistant, this creates a slider/number input with:
    # - Minimum position at 'min' value (left side of slider)
    # - Maximum position at 'max' value (right side of slider) 
    # - Each click/step moves by 'step' amount
    # - Starts at 'initial' position when first loaded
    #
    # The range (max - min) determines slider sensitivity:
    # - Small range (min: 10, max: 20) = sensitive, precise control
    # - Large range (min: 5, max: 50) = less sensitive, broad control
    #
    # WHEN TO CHANGE THESE VALUES:
    #
    # Change MIN if:
    # - You want to prevent accidental low settings: increase min to 8-10%
    # - You have robust batteries that can handle lower levels: decrease min to 3-5%
    #
    # Change MAX if:
    # - You want to limit over-conservative settings: decrease max to 25-30%
    # - You want flexibility for very conservative protection: increase max to 60%
    #
    # Change STEP if:
    # - You want fine-grained control: set step to 0.5 or 0.1
    # - You prefer simple, quick adjustments: set step to 5 or 10
    #
    # Change INITIAL if:
    # - Your battery chemistry has different safe discharge levels
    # - You want a different starting point based on your use case
    # - You've determined an optimal value through testing
    
    # PROTECTION THRESHOLD EXPLANATION:
    # This threshold creates an additional safety layer beyond just protecting the "lowest" battery.
    # 
    # How it works:
    # - Any battery below this percentage will have its discharging disabled
    # - This protects multiple batteries simultaneously if several are critically low
    # - Works in combination with the "lowest battery" protection
    # 
    # Example scenarios with 15% threshold:
    # 
    # Scenario 1: Batteries at 80%, 75%, 70%, 12%
    # Result: The 12% battery gets protected (both lowest AND below threshold)
    # 
    # Scenario 2: Batteries at 25%, 14%, 13%, 12% 
    # Result: All three batteries (14%, 13%, 12%) get protected as they're below 15%
    #         Only the 25% battery keeps discharging
    # 
    # Scenario 3: Batteries at 20%, 18%, 16%, 10%
    # Result: Only the 10% battery gets protected (lowest), others stay discharging
    #         because 20%, 18%, 16% are above the 15% threshold
    # 
    # Why use a threshold:
    # - Prevents deep discharge damage to batteries
    # - Creates consistent protection behavior 
    # - Allows multiple batteries to be protected when overall charge is low
    # - Provides early warning protection before batteries reach critical levels
    # 
    # Recommended settings:
    # - Conservative: 20-25% (protects batteries early, may limit available power)
    # - Balanced: 15% (good protection with reasonable power availability) 
    # - Aggressive: 10% (maximum power availability, minimal protection)
    # - Emergency only: 5% (only protects against severe damage)

# Template sensors for monitoring
template:
  - sensor:
      - name: "Battery Manager Status"
        unique_id: battery_manager_status
        state: >
          {% set batteries = states.sensor 
            | selectattr('entity_id', 'search', '_battery_level$')
            | selectattr('state', 'is_number')
            | list %}
          {% if batteries | length == 0 %}
            No Batteries
          {% elif batteries | length == 1 %}
            Single Battery
          {% else %}
            {{ batteries | length }} Batteries
          {% endif %}
        attributes:
          battery_count: >
            {% set batteries = states.sensor 
              | selectattr('entity_id', 'search', '_battery_level$')
              | selectattr('state', 'is_number')
              | list %}
            {{ batteries | length }}
          
          all_batteries: >
            {% set batteries = states.sensor 
              | selectattr('entity_id', 'search', '_battery_level$')
              | selectattr('state', 'is_number')
              | list %}
            {% set result = [] %}
            {% for battery in batteries %}
              {% set switch_entity = 'switch.' + battery.entity_id.split('.')[1].replace('_battery_level', '_battery_discharging') %}
              {% set battery_info = {
                'entity_id': battery.entity_id,
                'name': battery.attributes.friendly_name or battery.name,
                'level': battery.state | float,
                'switch_entity': switch_entity,
                'discharging': states(switch_entity) == 'on',
                'switch_available': not is_state(switch_entity, 'unavailable')
              } %}
              {% set result = result + [battery_info] %}
            {% endfor %}
            {{ result | sort(attribute='level') }}
          
          lowest_battery: >
            {% set batteries = states.sensor 
              | selectattr('entity_id', 'search', '_battery_level$')
              | selectattr('state', 'is_number')
              | list %}
            {% if batteries | length > 0 %}
              {% set lowest = batteries | min(attribute='state') %}
              {{ lowest.attributes.friendly_name or lowest.name }}
            {% else %}
              None
            {% endif %}
          
          lowest_level: >
            {% set batteries = states.sensor 
              | selectattr('entity_id', 'search', '_battery_level$')
              | selectattr('state', 'is_number')
              | list %}
            {% if batteries | length > 0 %}
              {{ (batteries | min(attribute='state')).state | float }}
            {% else %}
              0
            {% endif %}
          
          protection_active: >
            {% if not is_state('input_boolean.battery_protection_enabled', 'on') %}
              false
            {% else %}
              {% set batteries = states.sensor 
                | selectattr('entity_id', 'search', '_battery_level$')
                | selectattr('state', 'is_number')
                | list %}
              {% if batteries | length <= 1 %}
                false
              {% else %}
                {% set lowest = batteries | min(attribute='state') %}
                {% set switch_entity = 'switch.' + lowest.entity_id.split('.')[1].replace('_battery_level', '_battery_discharging') %}
                {{ states(switch_entity) == 'off' }}
              {% endif %}
            {% endif %}
        
        icon: >
          {% if state_attr('sensor.battery_manager_status', 'protection_active') %}
            mdi:shield-check
          {% else %}
            mdi:shield-outline
          {% endif %}

# Main automation for battery protection
automation:
  - id: advanced_battery_protection
    alias: "Advanced Battery Protection"
    description: "Intelligent battery discharge management with safety features"
    trigger:
      - platform: time_pattern
        minutes: "*"  # Every minute
      - platform: state
        entity_id: input_boolean.battery_protection_enabled
        to: "on"
    
    condition:
      - condition: state
        entity_id: input_boolean.battery_protection_enabled
        state: "on"
    
    variables:
      batteries: >
        {% set batteries = states.sensor 
          | selectattr('entity_id', 'search', '_battery_level$')
          | selectattr('state', 'is_number')
          | list %}
        {{ batteries | list }}
      
      # Protection threshold from input helper
      # This creates a "safety zone" - any battery below this % gets protected
      threshold: "{{ states('input_number.battery_protection_threshold') | float }}"
      
      lowest_battery: >
        {% set batteries = states.sensor 
          | selectattr('entity_id', 'search', '_battery_level$')
          | selectattr('state', 'is_number')
          | list %}
        {% if batteries | length > 0 %}
          {{ batteries | min(attribute='state') }}
        {% endif %}
      
      # List of all batteries currently below the protection threshold
      # These will be candidates for protection regardless of being "lowest"
      critical_batteries: >
        {% set batteries = states.sensor 
          | selectattr('entity_id', 'search', '_battery_level$')
          | selectattr('state', 'is_number')
          | list %}
        {% set threshold = states('input_number.battery_protection_threshold') | float %}
        {{ batteries | selectattr('state', 'float', '<', threshold) | list }}
    
    action:
      # Skip if less than 2 batteries
      - condition: template
        value_template: "{{ batteries | length > 1 }}"
      
      # Log current status
      - service: system_log.write
        data:
          message: >
            🔋 Battery Protection Check: {{ batteries | length }} batteries found. 
            Lowest: {{ lowest_battery.attributes.friendly_name or lowest_battery.name }} at {{ lowest_battery.state }}%.
            Protection threshold: {{ threshold }}% ({{ critical_batteries | length }} batteries below threshold).
            Currently protected: {{ (batteries | selectattr('entity_id', 'search', '_battery_level$') | map('regex_replace', '(.*)_battery_level$', 'switch.\\1_battery_discharging') | select('state', 'off') | list | length) }}/{{ batteries | length }}
          level: debug
          logger: battery_protection
      
      # Smart battery management with protection limits
      - repeat:
          for_each: "{{ batteries }}"
          sequence:
            - variables:
                current_battery: "{{ repeat.item }}"
                battery_level: "{{ repeat.item.state | float }}"
                battery_name: "{{ repeat.item.attributes.friendly_name or repeat.item.name }}"
                switch_entity: "switch.{{ repeat.item.entity_id.split('.')[1].replace('_battery_level', '_battery_discharging') }}"
                is_lowest: "{{ repeat.item.entity_id == lowest_battery.entity_id }}"
                is_critical: "{{ battery_level < threshold }}"
                switch_available: "{{ not is_state(switch_entity, 'unavailable') }}"
                switch_state: "{{ states(switch_entity) }}"
                
                # Count currently protected batteries
                currently_off_count: >
                  {% set off_count = 0 %}
                  {% for bat in batteries %}
                    {% set bat_switch = 'switch.' + bat.entity_id.split('.')[1].replace('_battery_level', '_battery_discharging') %}
                    {% if states(bat_switch) == 'off' %}
                      {% set off_count = off_count + 1 %}
                    {% endif %}
                  {% endfor %}
                  {{ off_count }}
                
                # Calculate maximum allowed protected batteries
                max_protected_count: >
                  {% set total = batteries | length %}
                  {% if total <= 1 %}
                    0
                  {% elif total == 2 %}
                    1
                  {% elif total == 3 %}
                    1
                  {% else %}
                    {{ total - 3 }}
                  {% endif %}
            
            # Only proceed if switch is available
            - condition: template
              value_template: "{{ switch_available }}"
            
            - choose:
                # Case 1: Battery is ON but needs protection - turn OFF (if allowed)
                # A battery needs protection if it's EITHER:
                # - The lowest battery among all batteries, OR
                # - Below the protection threshold (critical level)
                - conditions:
                    - condition: template
                      value_template: "{{ (is_lowest or is_critical) and switch_state == 'on' }}"
                    - condition: template
                      value_template: "{{ currently_off_count < max_protected_count }}"
                  sequence:
                    - service: switch.turn_off
                      target:
                        entity_id: "{{ switch_entity }}"
                    - service: system_log.write
                      data:
                        message: >
                          🛡️ PROTECTED: {{ battery_name }} ({{ battery_level }}%) - turned OFF
                          {% if is_lowest %} (lowest battery){% endif %}
                          {% if is_critical %} (below {{ threshold }}% threshold){% endif %}
                        level: warning
                        logger: battery_protection
                
                # Case 2: Battery is OFF but no longer needs protection - turn ON
                # A battery can be re-enabled if it's BOTH:
                # - NOT the lowest battery, AND  
                # - ABOVE the protection threshold
                # AND we have too many batteries protected (exceeding our minimum requirements)
                - conditions:
                    - condition: template
                      value_template: "{{ not is_lowest and not is_critical and switch_state == 'off' }}"
                    - condition: template
                      value_template: "{{ currently_off_count > max_protected_count }}"
                  sequence:
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ switch_entity }}"
                    - service: system_log.write
                      data:
                        message: >
                          ✅ ENABLED: {{ battery_name }} ({{ battery_level }}%) - turned ON 
                          (above {{ threshold }}% threshold and not lowest)
                        level: info
                        logger: battery_protection
                
                # Case 3: Proactive protection to maintain minimum discharging requirement
                # Even if a battery isn't lowest or critical, we may need to protect it
                # to ensure we don't have too few protected batteries overall
                - conditions:
                    - condition: template
                      value_template: "{{ not is_lowest and not is_critical and switch_state == 'on' and currently_off_count < max_protected_count }}"
                    - condition: template
                      value_template: >
                        {% set sorted_batteries = batteries | sort(attribute='state') %}
                        {% set battery_position = sorted_batteries | map(attribute='entity_id') | list | index(repeat.item.entity_id) %}
                        {{ battery_position < max_protected_count }}
                  sequence:
                    - service: switch.turn_off
                      target:
                        entity_id: "{{ switch_entity }}"
                    - service: system_log.write
                      data:
                        message: >
                          🛡️ PROTECTED: {{ battery_name }} ({{ battery_level }}%) - turned OFF 
                          (among lowest needing protection to maintain minimum discharging)
                        level: warning
                        logger: battery_protection

  # Emergency automation for very low batteries
  - id: battery_emergency_protection
    alias: "Battery Emergency Protection"
    description: "Immediate protection for critically low batteries"
    trigger:
      - platform: numeric_state
        entity_id: 
          - sensor
        below: 5  # Emergency threshold at 5%
        for:
          seconds: 10
    
    condition:
      - condition: template
        value_template: >
          {{ trigger.entity_id.endswith('_battery_level') and 
             trigger.to_state.state | float < 5 }}
    
    action:
      - variables:
          battery_entity: "{{ trigger.entity_id }}"
          switch_entity: "switch.{{ trigger.entity_id.split('.')[1].replace('_battery_level', '_battery_discharging') }}"
          battery_name: "{{ trigger.to_state.attributes.friendly_name or trigger.to_state.name }}"
          battery_level: "{{ trigger.to_state.state | float }}"
      
      - service: switch.turn_off
        target:
          entity_id: "{{ switch_entity }}"
      
      - service: system_log.write
        data:
          message: >
            🚨 EMERGENCY: Force disabled discharging for {{ battery_name }} 
            ({{ battery_level }}% - CRITICAL LOW!)
          level: critical
          logger: battery_protection

# Notification automation (optional)
  - id: battery_status_notification
    alias: "Battery Status Notification"
    description: "Daily battery status report"
    trigger:
      - platform: time
        at: "08:00:00"  # Daily at 8 AM
    
    condition:
      - condition: state
        entity_id: input_boolean.battery_protection_enabled
        state: "on"
    
    action:
      - service: system_log.write
        data:
          message: >
            📊 Daily Battery Report: 
            {{ state_attr('sensor.battery_manager_status', 'battery_count') }} batteries monitored. 
            Lowest: {{ state_attr('sensor.battery_manager_status', 'lowest_battery') }} 
            at {{ state_attr('sensor.battery_manager_status', 'lowest_level') }}%. 
            Protection: {{ 'Active' if state_attr('sensor.battery_manager_status', 'protection_active') else 'Inactive' }}
          level: info
          logger: battery_protection
