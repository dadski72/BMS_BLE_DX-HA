# Battery Protection Automation for Home Assistant
# This automation manages battery discharging based on SOC levels
# and protects against over-discharge by managing the solar inverter
# NOTE: Requires average_batteries_sensor.yaml to be included for the Average Battery SOC sensor

# Main Battery Protection Automation
automation:
  - id: battery_protection_system
    alias: "Battery Protection System"
    description: "Manages battery discharging based on SOC levels and protects against over-discharge"
    trigger:
      - platform: time_pattern
        minutes: "*"  # Run every minute
    condition:
      # Only run if we have sufficient battery data available
      - condition: template
        value_template: >
          {% set ns = namespace(valid_count=0) %}
          {% for state in states.sensor %}
            {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
              {% set state_val = state.state | string %}
              {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                {% set ns.valid_count = ns.valid_count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.valid_count >= 3 }}
    action:
      - variables:
          # Discover all battery entities using the pattern
          batteries: >
            {% set ns = namespace(battery_list=[]) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set battery_id = state.entity_id | regex_replace('^sensor\.dadski_battery_([a-z][0-9]+)_soc$', '\\1') %}
                {% set battery_dict = {
                  'name': battery_id,
                  'soc': state.entity_id,
                  'switch': 'switch.dadski_battery_' + battery_id + '_discharging',
                  'current': 'sensor.dadski_battery_' + battery_id + '_current',
                  'voltage': 'sensor.dadski_battery_' + battery_id + '_voltage'
                } %}
                {% set ns.battery_list = ns.battery_list + [battery_dict] %}
              {% endif %}
            {% endfor %}
            {{ ns.battery_list }}
          
          # Get valid batteries (with numeric SOC values and available states)
          valid_batteries: >
            {% set ns = namespace(valid=[]) %}
            {% for battery in batteries %}
              {% set soc_state = states(battery.soc) | string %}
              {% set switch_state = states(battery.switch) | string %}
              {% if soc_state | is_number and 
                   soc_state not in ['unavailable', 'unknown'] and
                   switch_state not in ['unavailable', 'unknown'] and
                   soc_state | float >= 0 and soc_state | float <= 100 %}
                {% set ns.valid = ns.valid + [battery] %}
              {% endif %}
            {% endfor %}
            {{ ns.valid }}
          
          # Get battery availability status for logging
          battery_availability: >
            {% set ns = namespace(status=[]) %}
            {% for battery in batteries %}
              {% set soc_state = states(battery.soc) | string %}
              {% set switch_state = states(battery.switch) | string %}
              {% set available = soc_state | is_number and 
                               soc_state not in ['unavailable', 'unknown'] and
                               switch_state not in ['unavailable', 'unknown'] %}
              {% set ns.status = ns.status + [battery.name + ': ' + ('OK' if available else 'UNAVAILABLE')] %}
            {% endfor %}
            {{ ns.status | join(', ') }}
          
          # Find the highest SOC among all valid batteries
          highest_soc: >
            {% set ns = namespace(max_soc=0) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% if soc_val > ns.max_soc %}
                {% set ns.max_soc = soc_val %}
              {% endif %}
            {% endfor %}
            {{ ns.max_soc }}
          
          # Get sorted SOC values for logging and reference
          sorted_soc_data: >
            {% set ns = namespace(soc_list=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% set ns.soc_list = ns.soc_list + [{'name': battery.name, 'soc': soc_val, 'switch': battery.switch}] %}
            {% endfor %}
            {{ ns.soc_list | sort(attribute='soc') }}
          
          # Determine which batteries should be turned off (SOC <= highest_soc - 2)
          batteries_to_turn_off: >
            {% set ns = namespace(turnoff_list=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% if soc_val <= (highest_soc - 2) %}
                {% set ns.turnoff_list = ns.turnoff_list + [{'name': battery.name, 'soc': soc_val, 'switch': battery.switch}] %}
              {% endif %}
            {% endfor %}
            {{ ns.turnoff_list }}
          
          # Determine which batteries should be turned on (SOC >= highest_soc)
          batteries_to_turn_on: >
            {% set ns = namespace(turnon_list=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% if soc_val >= highest_soc %}
                {% set ns.turnon_list = ns.turnon_list + [{'name': battery.name, 'soc': soc_val, 'switch': battery.switch}] %}
              {% endif %}
            {% endfor %}
            {{ ns.turnon_list }}
          
          # Get average SOC
          average_soc: >
            {% set ns = namespace(soc_values=[]) %}
            {% for battery in valid_batteries %}
              {% set ns.soc_values = ns.soc_values + [states(battery.soc) | float] %}
            {% endfor %}
            {% if ns.soc_values | length > 0 %}
              {{ (ns.soc_values | sum / ns.soc_values | length) | round(1) }}
            {% else %}
              0
            {% endif %}

      # Log current status including battery availability
      - service: system_log.write
        data:
          message: >
            Battery Protection: Average SOC: {{ average_soc }}%, 
            Highest SOC: {{ highest_soc }}%,
            Valid batteries: {{ valid_batteries | length }}/{{ batteries | length }}, 
            Batteries to turn off: {{ batteries_to_turn_off | length }},
            Batteries to turn on: {{ batteries_to_turn_on | length }},
            Battery status: {{ battery_availability }}
          level: info

      # Log the new logic reasoning
      - service: system_log.write
        data:
          message: "Battery Protection Logic: Turn OFF batteries with SOC <= {{ highest_soc - 2 }}%, Turn ON batteries with SOC >= {{ highest_soc }}%"
          level: info

      # Log sorted battery data for debugging
      - service: system_log.write
        data:
          message: >
            Sorted batteries by SOC: 
            {% for battery in sorted_soc_data %}{{ battery.name }}={{ battery.soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
          level: info

      # Log which batteries are marked for turn off
      - service: system_log.write
        data:
          message: >
            Batteries marked for turn OFF (SOC <= {{ highest_soc - 2 }}%): 
            {% if batteries_to_turn_off | length > 0 %}
              {% for battery in batteries_to_turn_off %}{{ battery.name }}={{ battery.soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
            {% else %}
              None
            {% endif %}
          level: info

      # Log which batteries are marked for turn on
      - service: system_log.write
        data:
          message: >
            Batteries marked for turn ON (SOC >= {{ highest_soc }}%): 
            {% if batteries_to_turn_on | length > 0 %}
              {% for battery in batteries_to_turn_on %}{{ battery.name }}={{ battery.soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
            {% else %}
              None
            {% endif %}
          level: info

      # Log detailed decision making for each battery
      - repeat:
          for_each: "{{ valid_batteries }}"
          sequence:
            - variables:
                battery_soc: "{{ states(repeat.item.soc) | float }}"
                battery_switch_state: "{{ states(repeat.item.switch) | string }}"
                is_in_turnoff_list: >
                  {% set ns = namespace(found=false) %}
                  {% for battery in batteries_to_turn_off %}
                    {% if battery.name == repeat.item.name %}
                      {% set ns.found = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.found }}
                is_in_turnon_list: >
                  {% set ns = namespace(found=false) %}
                  {% for battery in batteries_to_turn_on %}
                    {% if battery.name == repeat.item.name %}
                      {% set ns.found = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.found }}
                planned_action: >
                  {% set soc = states(repeat.item.soc) | float %}
                  {% if soc <= (highest_soc - 2) %}
                    {% if is_state(repeat.item.switch, 'on') %}
                      TURN_OFF
                    {% else %}
                      ALREADY_OFF
                    {% endif %}
                  {% elif soc >= highest_soc %}
                    {% if is_state(repeat.item.switch, 'off') %}
                      TURN_ON
                    {% else %}
                      KEEP_ON
                    {% endif %}
                  {% else %}
                    {% if is_state(repeat.item.switch, 'on') %}
                      KEEP_ON
                    {% else %}
                      KEEP_OFF
                    {% endif %}
                  {% endif %}
                decision_reason: >
                  {% set soc = states(repeat.item.soc) | float %}
                  {% if soc <= (highest_soc - 2) %}
                    "SOC {{ soc }}% <= {{ highest_soc - 2 }}% (highest - 2) - should be OFF"
                  {% elif soc >= highest_soc %}
                    "SOC {{ soc }}% >= {{ highest_soc }}% (highest) - should be ON"
                  {% else %}
                    "SOC {{ soc }}% is between {{ highest_soc - 2 }}% and {{ highest_soc }}% - no change"
                  {% endif %}
            - service: system_log.write
              data:
                message: >
                  Battery {{ repeat.item.name }}: SOC={{ battery_soc }}%, 
                  Switch={{ battery_switch_state }}, 
                  InTurnOffList={{ is_in_turnoff_list }}, 
                  InTurnOnList={{ is_in_turnon_list }},
                  PlannedAction={{ planned_action }}, 
                  Reason={{ decision_reason }}
                level: info

      # Skip battery management if we don't have enough valid batteries
      - condition: template
        value_template: "{{ valid_batteries | length >= 3 }}"

      # Check if any battery is currently charging (current > 0)
      - variables:
          any_battery_charging: >
            {% set ns = namespace(active=false) %}
            {% for battery in valid_batteries %}
              {% set current_val = states(battery.current) | float(0) %}
              {% if current_val > 0 %}
                {% set ns.active = true %}
              {% endif %}
            {% endfor %}
            {{ ns.active }}

      # Log if we're skipping turn-off logic due to active charging
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ any_battery_charging }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: Skipping turn-off logic - at least one battery is actively charging (current > 0)"
                  level: warning
        default:
          # Only proceed with turn-off logic if no batteries are charging
          - service: system_log.write
            data:
              message: "Battery Protection: No batteries currently charging - proceeding with battery management logic"
              level: info

          # Turn off discharging for batteries with SOC <= highest_soc - 2
          - repeat:
              for_each: "{{ batteries_to_turn_off }}"
              sequence:
                - service: system_log.write
                  data:
                    message: "Battery Protection: Processing {{ repeat.item.name }} for TURN OFF (SOC: {{ repeat.item.soc }}%, Switch: {{ states(repeat.item.switch) }})"
                    level: info
                - choose:
                    - conditions:
                        - condition: and
                          conditions:
                            - condition: template
                              value_template: "{{ is_state(repeat.item.switch, 'on') }}"
                            - condition: template
                              value_template: >
                                {% set soc_val = repeat.item.soc | string %}
                                {{ soc_val | is_number and soc_val not in ['unavailable', 'unknown'] }}
                      sequence:
                        - service: switch.turn_off
                          target:
                            entity_id: "{{ repeat.item.switch }}"
                        - service: system_log.write
                          data:
                            message: "Battery Protection: ✓ TURNED OFF discharging for {{ repeat.item.name }} (SOC: {{ repeat.item.soc | string }}%) - REASON: SOC <= {{ highest_soc - 2 }}% (highest - 2)"
                            level: warning
                  default:
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✗ IGNORED turn OFF for {{ repeat.item.name }} - REASON: Conditions not met"
                        level: info

          # Turn on discharging for batteries with SOC >= highest_soc
          - repeat:
              for_each: "{{ batteries_to_turn_on }}"
              sequence:
                - service: system_log.write
                  data:
                    message: "Battery Protection: Processing {{ repeat.item.name }} for TURN ON (SOC: {{ repeat.item.soc }}%, Switch: {{ states(repeat.item.switch) }})"
                    level: info
                - choose:
                    - conditions:
                        - condition: and
                          conditions:
                            - condition: template
                              value_template: "{{ is_state(repeat.item.switch, 'off') }}"
                            - condition: template
                              value_template: >
                                {% set soc_val = repeat.item.soc | string %}
                                {{ soc_val | is_number and soc_val not in ['unavailable', 'unknown'] }}
                      sequence:
                        - service: switch.turn_on
                          target:
                            entity_id: "{{ repeat.item.switch }}"
                        - service: system_log.write
                          data:
                            message: "Battery Protection: ✓ TURNED ON discharging for {{ repeat.item.name }} (SOC: {{ repeat.item.soc | string }}%) - REASON: SOC >= {{ highest_soc }}% (highest)"
                            level: warning
                  default:
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✗ IGNORED turn ON for {{ repeat.item.name }} - REASON: Conditions not met"
                        level: info

      # Enhanced battery charging management with balancing detection to prevent oscillation
      - variables:
          any_battery_charging_for_switch_management: >
            {% set ns = namespace(active=false) %}
            {% for battery in valid_batteries %}
              {% set current_val = states(battery.current) | float(0) %}
              {% if current_val > 0 %}
                {% set ns.active = true %}
              {% endif %}
            {% endfor %}
            {{ ns.active }}
          
          battery_balancing_active: >
            {% set ns = namespace(charging=0, discharging=0) %}
            {% for battery in valid_batteries %}
              {% set current = states(battery.current) | float(0) %}
              {% if current > 0.5 %}
                {% set ns.charging = ns.charging + 1 %}
              {% elif current < -0.5 %}
                {% set ns.discharging = ns.discharging + 1 %}
              {% endif %}
            {% endfor %}
            {{ ns.charging > 0 and ns.discharging > 0 and states('sensor.solar_pv_combine') | float(0) < 10 }}
          
          external_charging_active: >
            {% set solar_pv = states('sensor.solar_pv_combine') | float(0) %}
            {{ any_battery_charging_for_switch_management and solar_pv >= 50 }}
          
          soc_spread: >
            {% set ns = namespace(soc_values=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float(0) %}
              {% set ns.soc_values = ns.soc_values + [soc_val] %}
            {% endfor %}
            {% if ns.soc_values | length > 0 %}
              {{ (ns.soc_values | max) - (ns.soc_values | min) }}
            {% else %}
              0
            {% endif %}

      - choose:
          # External charging detected (solar >= 50W) - turn on all batteries
          - conditions:
              - condition: template
                value_template: "{{ external_charging_active }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: External charging detected (solar: {{ states('sensor.solar_pv_combine') | float(0) }}W). Turning ON all batteries."
                  level: warning
              - repeat:
                  for_each: "{{ valid_batteries }}"
                  sequence:
                    - condition: template
                      value_template: "{{ is_state(repeat.item.switch, 'off') }}"
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ repeat.item.switch }}"
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✓ TURNED ON {{ repeat.item.name }} - external charging detected"
                        level: warning

          # Battery balancing detected - maintain current state to prevent oscillation
          - conditions:
              - condition: template
                value_template: "{{ battery_balancing_active }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: Battery balancing detected (SOC spread: {{ soc_spread }}%, solar: {{ states('sensor.solar_pv_combine') | float(0) }}W). Maintaining current switch states to prevent oscillation."
                  level: warning

      # Solar inverter management based on average SOC (only if we have valid data)
      - choose:
          # Turn off solar inverter if average SOC <= 40% and inverter is on
          - conditions:
              - condition: template
                value_template: "{{ average_soc > 0 and average_soc <= 40 and valid_batteries | length >= 3 }}"
              - condition: state
                entity_id: switch.solar_inverter
                state: "on"
            sequence:
              - service: switch.turn_off
                target:
                  entity_id: switch.solar_inverter
              - service: system_log.write
                data:
                  message: "Battery Protection: Turned OFF solar inverter (Average SOC: {{ average_soc }}%)"
                  level: warning
          
          # Turn on solar inverter if average SOC >= 50% and inverter is off
          - conditions:
              - condition: template
                value_template: "{{ average_soc >= 50 and valid_batteries | length >= 3 }}"
              - condition: state
                entity_id: switch.solar_inverter
                state: "off"
            sequence:
              - service: switch.turn_on
                target:
                  entity_id: switch.solar_inverter
              - service: system_log.write
                data:
                  message: "Battery Protection: Turned ON solar inverter (Average SOC: {{ average_soc }}%)"
                  level: info
        
        # Log when we skip inverter management due to insufficient data
        default:
          - condition: template
            value_template: "{{ valid_batteries | length < 3 }}"
          - service: system_log.write
            data:
              message: "Battery Protection: Skipping inverter management - insufficient valid battery data ({{ valid_batteries | length }}/{{ batteries | length }} batteries available)"
              level: warning

    mode: single
    max_exceeded: silent

# Battery startup monitoring automation
  - id: battery_startup_monitor
    alias: "Battery Startup Monitor"
    description: "Monitors battery availability during startup and sends notifications"
    trigger:
      - platform: homeassistant
        event: start
      - platform: time_pattern
        minutes: "/5"  # Check every 5 minutes
    condition:
      # Only run if we have insufficient batteries (removed uptime dependency)
      - condition: template
        value_template: >
          {% set ns = namespace(valid_count=0) %}
          {% for state in states.sensor %}
            {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
              {% set state_val = state.state | string %}
              {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                {% set ns.valid_count = ns.valid_count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.valid_count < 3 }}
    action:
      - variables:
          battery_status: >
            {% set ns = namespace(status=[]) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set battery_name = state.entity_id | regex_replace('^sensor\.dadski_battery_([a-z][0-9]+)_soc$', '\\1') %}
                {% set state_val = state.state | string %}
                {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                  {% set ns.status = ns.status + [battery_name + ': ' + state_val + '%'] %}
                {% else %}
                  {% set ns.status = ns.status + [battery_name + ': ' + state_val] %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.status | join(', ') }}
          
          available_count: >
            {% set ns = namespace(valid_count=0) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set state_val = state.state | string %}
                {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                  {% set ns.valid_count = ns.valid_count + 1 %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.valid_count }}
          
          total_batteries: >
            {% set ns = namespace(total_count=0) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set ns.total_count = ns.total_count + 1 %}
              {% endif %}
            {% endfor %}
            {{ ns.total_count }}

      - service: system_log.write
        data:
          message: "Battery Startup Monitor: {{ available_count }}/{{ total_batteries }} batteries available. Status: {{ battery_status }}"
          level: info

      - condition: template
        value_template: "{{ available_count < 3 }}"
      
      - service: notify.persistent_notification
        data:
          title: "Battery System Status"
          message: "Only {{ available_count }}/{{ total_batteries }} batteries are currently available. Battery protection is paused until at least 3 batteries are online. Status: {{ battery_status }}"
          notification_id: "battery_startup_status"

    mode: single
    max_exceeded: silent
