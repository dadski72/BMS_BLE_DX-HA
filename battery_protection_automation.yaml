# Battery Protection Automation for Home Assistant
# This automation manages battery discharging based on SOC levels
# and protects against over-discharge by managing the solar inverter
# NOTE: Requires average_batteries_sensor.yaml to be included for the Average Battery SOC sensor

# Main Battery Protection Automation
automation:
  - id: battery_protection_system
    alias: "Battery Protection System"
    description: "Manages battery discharging based on SOC levels and protects against over-discharge"
    trigger:
      - platform: time_pattern
        minutes: "*"  # Run every minute
      - platform: homeassistant
        event: start  # Trigger on Home Assistant restart
      - platform: state
        entity_id: automation.battery_protection_system
        to: "on"  # Trigger when automation is turned on
    condition:
      # Only run if we have sufficient battery data available
      - condition: template
        value_template: >
          {% set ns = namespace(valid_count=0) %}
          {% for state in states.sensor %}
            {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
              {% set state_val = state.state | string %}
              {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                {% set ns.valid_count = ns.valid_count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.valid_count >= 3 }}
    action:
      - variables:
          # Check if this is a system restart/reset (automation just turned on)
          automation_just_started: >
            {{ trigger.platform == 'homeassistant' or 
               (trigger.platform == 'state' and trigger.to_state.state == 'on') }}
          
          # Discover all battery entities using the pattern
          batteries: >
            {% set ns = namespace(battery_list=[]) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set battery_id = state.entity_id | regex_replace('^sensor\.dadski_battery_([a-z][0-9]+)_soc$', '\\1') %}
                {% set battery_dict = {
                  'name': battery_id,
                  'soc': state.entity_id,
                  'switch': 'switch.dadski_battery_' + battery_id + '_discharging',
                  'current': 'sensor.dadski_battery_' + battery_id + '_current',
                  'voltage': 'sensor.dadski_battery_' + battery_id + '_voltage'
                } %}
                {% set ns.battery_list = ns.battery_list + [battery_dict] %}
              {% endif %}
            {% endfor %}
            {{ ns.battery_list }}
          
          # Get valid batteries (with numeric SOC values and available states)
          valid_batteries: >
            {% set ns = namespace(valid=[]) %}
            {% for battery in batteries %}
              {% set soc_state = states(battery.soc) | string %}
              {% set switch_state = states(battery.switch) | string %}
              {% if soc_state | is_number and 
                   soc_state not in ['unavailable', 'unknown'] and
                   switch_state not in ['unavailable', 'unknown'] and
                   soc_state | float >= 0 and soc_state | float <= 100 %}
                {% set ns.valid = ns.valid + [battery] %}
              {% endif %}
            {% endfor %}
            {{ ns.valid }}
          
          # Get battery availability status for logging
          battery_availability: >
            {% set ns = namespace(status=[]) %}
            {% for battery in batteries %}
              {% set soc_state = states(battery.soc) | string %}
              {% set switch_state = states(battery.switch) | string %}
              {% set available = soc_state | is_number and 
                               soc_state not in ['unavailable', 'unknown'] and
                               switch_state not in ['unavailable', 'unknown'] %}
              {% set ns.status = ns.status + [battery.name + ': ' + ('OK' if available else 'UNAVAILABLE')] %}
            {% endfor %}
            {{ ns.status | join(', ') }}
          
          # Find the highest SOC among all valid batteries (needed for peak initialization)
          highest_soc: >
            {% set ns = namespace(max_soc=0) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% if soc_val > ns.max_soc %}
                {% set ns.max_soc = soc_val %}
              {% endif %}
            {% endfor %}
            {{ ns.max_soc }}
          
          # Store/update highest SOC for each battery (per-battery memory)
          battery_peak_socs: >
            {% set ns = namespace(peak_data=[]) %}
            {% for battery in valid_batteries %}
              {% set current_soc = states(battery.soc) | float %}
              {% set peak_entity = 'input_number.battery_' + battery.name + '_peak_soc' %}
              {% set prev_entity = 'input_number.battery_' + battery.name + '_previous_soc' %}
              {% set stored_peak = states(peak_entity) | float(0) %}
              {% set previous_soc = states(prev_entity) | float(current_soc) %}
              {# Initialize stored_peak to highest_soc if it's 0 (first run) OR if automation just started (reset) #}
              {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
              {% set new_peak = [current_soc, initial_peak] | max %}
              {% set soc_increasing = current_soc > previous_soc %}
              {% set soc_decreasing = current_soc < previous_soc %}
              {% set soc_change = current_soc - previous_soc %}
              {% set ns.peak_data = ns.peak_data + [{'name': battery.name, 'current_soc': current_soc, 'previous_soc': previous_soc, 'stored_peak': stored_peak, 'initial_peak': initial_peak, 'new_peak': new_peak, 'soc_increasing': soc_increasing, 'soc_decreasing': soc_decreasing, 'soc_change': soc_change, 'entity': peak_entity, 'prev_entity': prev_entity, 'force_reset': automation_just_started}] %}
            {% endfor %}
            {{ ns.peak_data }}
          
          # Get sorted SOC values for logging and reference
          sorted_soc_data: >
            {% set ns = namespace(soc_list=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% set ns.soc_list = ns.soc_list + [{'name': battery.name, 'soc': soc_val, 'switch': battery.switch}] %}
            {% endfor %}
            {{ ns.soc_list | sort(attribute='soc') }}
          
          # Determine which batteries should be turned off using stored peak SOC values
          batteries_to_turn_off: >
            {% set ns = namespace(turnoff_list=[]) %}
            {% set batteries_currently_on = [] %}
            {% for battery in valid_batteries %}
              {% if is_state(battery.switch, 'on') %}
                {% set batteries_currently_on = batteries_currently_on + [battery.name] %}
              {% endif %}
            {% endfor %}
            {% for battery in valid_batteries %}
              {% set current_soc = states(battery.soc) | float %}
              {% set peak_entity = 'input_number.battery_' + battery.name + '_peak_soc' %}
              {% set stored_peak = states(peak_entity) | float(0) %}
              {# Initialize stored_peak to highest_soc if it's 0 (first run) OR if automation just started (reset) #}
              {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
              {# Always use the individual battery's peak SOC as reference #}
              {% set reference_soc = initial_peak %}
              {# Only add to turn-off list if SOC is low AND we have more than 1 battery currently on #}
              {% if current_soc <= (reference_soc - 2) and batteries_currently_on | length > 1 %}
                {% set ns.turnoff_list = ns.turnoff_list + [{'name': battery.name, 'soc': current_soc, 'switch': battery.switch, 'reference_soc': reference_soc, 'peak_soc': initial_peak}] %}
              {% endif %}
            {% endfor %}
            {{ ns.turnoff_list }}

      # DEBUG: Log detailed battery turn-off calculation
      - service: system_log.write
        data:
          message: >
            Battery Protection: DEBUG - Turn-off calculation details:
            {% for battery in valid_batteries %}
              {% set current_soc = states(battery.soc) | float %}
              {% set peak_entity = 'input_number.battery_' + battery.name + '_peak_soc' %}
              {% set stored_peak = states(peak_entity) | float(0) %}
              {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
              {% set reference_soc = initial_peak %}
              {% set batteries_currently_on = [] %}
              {% for bat in valid_batteries %}
                {% if is_state(bat.switch, 'on') %}
                  {% set batteries_currently_on = batteries_currently_on + [bat.name] %}
                {% endif %}
              {% endfor %}
              {% set condition_met = current_soc <= (reference_soc - 2) and batteries_currently_on | length > 1 %}
              {{ battery.name }}(SOC:{{ current_soc }}%,Peak:{{ initial_peak }}%,Ref:{{ reference_soc }}%,Threshold:{{ reference_soc - 2 }}%,Switch:{{ states(battery.switch) }},BattOn:{{ batteries_currently_on | length }},Condition:{{ condition_met }}){% if not loop.last %}, {% endif %}
            {% endfor %}
          level: warning
          
          # Determine which batteries should be turned on (SOC >= highest_soc)
          batteries_to_turn_on: >
            {% set ns = namespace(turnon_list=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float %}
              {% if soc_val >= highest_soc %}
                {% set ns.turnon_list = ns.turnon_list + [{'name': battery.name, 'soc': soc_val, 'switch': battery.switch}] %}
              {% endif %}
            {% endfor %}
            {{ ns.turnon_list }}
          
          # Get average SOC
          average_soc: >
            {% set ns = namespace(soc_values=[]) %}
            {% for battery in valid_batteries %}
              {% set ns.soc_values = ns.soc_values + [states(battery.soc) | float] %}
            {% endfor %}
            {% if ns.soc_values | length > 0 %}
              {{ (ns.soc_values | sum / ns.soc_values | length) | round(1) }}
            {% else %}
              0
            {% endif %}

      # Update stored peak SOC values and previous SOC values for each battery
      - repeat:
          for_each: "{{ battery_peak_socs }}"
          sequence:
            # Update previous SOC value
            - service: input_number.set_value
              target:
                entity_id: "{{ repeat.item.prev_entity }}"
              data:
                value: "{{ repeat.item.current_soc }}"
            
            # Additional turn-off logic during update cycle
            # Turn off battery if: discharging is ON AND current_soc < previous_soc AND (peak_soc - current_soc) <= 2
            # BUT only if there are more than 1 batteries currently ON
            # DISABLED FOR DEBUGGING - This logic may interfere with main turn-off logic
            - choose:
                - conditions:
                    - condition: template
                      value_template: "false"  # Temporarily disabled
                  sequence:
                    - service: switch.turn_off
                      target:
                        entity_id: "switch.dadski_battery_{{ repeat.item.name }}_discharging"
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✓ TURNED OFF discharging for {{ repeat.item.name }} during update cycle (SOC: {{ repeat.item.current_soc }}% < Previous: {{ repeat.item.previous_soc }}% AND Peak-Current: {{ repeat.item.initial_peak - repeat.item.current_soc }}% <= 2%) - REASON: SOC decreasing and close to peak"
                        level: warning
            
            # Update peak SOC only if it's higher than stored peak OR if automation just started (force reset)
            - condition: template
              value_template: "{{ repeat.item.new_peak > repeat.item.stored_peak or repeat.item.force_reset }}"
            - service: input_number.set_value
              target:
                entity_id: "{{ repeat.item.entity }}"
              data:
                value: "{{ repeat.item.new_peak }}"
            - service: system_log.write
              data:
                message: >
                  Battery Protection: Updated peak SOC for {{ repeat.item.name }}: 
                  {% if repeat.item.force_reset %}
                    RESET TO HIGHEST SOC {{ repeat.item.stored_peak }}% -> {{ repeat.item.new_peak }}% (automation restart)
                  {% elif repeat.item.stored_peak == 0 %}
                    INITIALIZED {{ repeat.item.initial_peak }}% -> {{ repeat.item.new_peak }}%
                  {% else %}
                    NORMAL UPDATE {{ repeat.item.stored_peak }}% -> {{ repeat.item.new_peak }}%
                  {% endif %}
                level: info

      # Log current status including battery availability and peak SOC data
      - service: system_log.write
        data:
          message: >
            Battery Protection: {% if automation_just_started %}[AUTOMATION RESTART] {% endif %}Average SOC: {{ average_soc }}%, 
            Highest SOC: {{ highest_soc }}%,
            Valid batteries: {{ valid_batteries | length }}/{{ batteries | length }}, 
            Batteries currently ON: {% set batteries_on = [] %}{% for battery in valid_batteries %}{% if is_state(battery.switch, 'on') %}{% set batteries_on = batteries_on + [battery.name] %}{% endif %}{% endfor %}{{ batteries_on | length }} ({{ batteries_on | join(', ') }}),
            Batteries to turn off: {{ batteries_to_turn_off | length }},
            Batteries to turn on: {{ batteries_to_turn_on | length }},
            Battery status: {{ battery_availability }}
          level: info

      # Log peak SOC tracking data with SOC changes
      - service: system_log.write
        data:
          message: >
            Peak SOC tracking: 
            {% for battery in battery_peak_socs %}{{ battery.name }}=Current:{{ battery.current_soc }}%/Previous:{{ battery.previous_soc }}%/Change:{{ battery.soc_change | round(1) }}%/Peak:{{ battery.new_peak }}%{% if not loop.last %}, {% endif %}{% endfor %}
          level: info

      # Log SOC trend analysis and update cycle actions
      - service: system_log.write
        data:
          message: >
            SOC Trends: 
            {% set increasing = battery_peak_socs | selectattr('soc_increasing', 'equalto', true) | list %}
            {% set decreasing = battery_peak_socs | selectattr('soc_decreasing', 'equalto', true) | list %}
            {% set stable = battery_peak_socs | rejectattr('soc_increasing', 'equalto', true) | rejectattr('soc_decreasing', 'equalto', true) | list %}
            Increasing: {% if increasing | length > 0 %}{% for battery in increasing %}{{ battery.name }}(+{{ battery.soc_change | round(1) }}%){% if not loop.last %}, {% endif %}{% endfor %}{% else %}None{% endif %} | 
            Decreasing: {% if decreasing | length > 0 %}{% for battery in decreasing %}{{ battery.name }}({{ battery.soc_change | round(1) }}%){% if not loop.last %}, {% endif %}{% endfor %}{% else %}None{% endif %} | 
            Stable: {% if stable | length > 0 %}{% for battery in stable %}{{ battery.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% else %}None{% endif %}
          level: info

      # Log batteries that were turned off during update cycle due to decreasing SOC
      - service: system_log.write
        data:
          message: >
            Update Cycle Turn-Off Actions: DISABLED FOR DEBUGGING
          level: info

      # Log the new logic reasoning with peak SOC tracking
      - service: system_log.write
        data:
          message: "Battery Protection Logic: Turn OFF batteries with SOC <= (individual_peak - 2)%, Turn ON batteries with SOC >= current_highest%. Always keep at least 1 battery ON."
          level: info

      # Log sorted battery data for debugging
      - service: system_log.write
        data:
          message: >
            Sorted batteries by SOC: 
            {% for battery in sorted_soc_data %}{{ battery.name }}={{ battery.soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
          level: info

      # Log which batteries are marked for turn off with reference SOC
      - service: system_log.write
        data:
          message: >
            Batteries marked for turn OFF: 
            {% if batteries_to_turn_off | length > 0 %}
              {% for battery in batteries_to_turn_off %}{{ battery.name }}=Current:{{ battery.soc }}%/Ref:{{ battery.reference_soc }}%/Peak:{{ battery.peak_soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
            {% else %}
              {% set blocked_batteries = [] %}
              {% for battery in valid_batteries %}
                {% set current_soc = states(battery.soc) | float %}
                {% set peak_entity = 'input_number.battery_' + battery.name + '_peak_soc' %}
                {% set stored_peak = states(peak_entity) | float(0) %}
                {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
                {% set reference_soc = initial_peak %}
                {% set batteries_currently_on = [] %}
                {% for bat in valid_batteries %}
                  {% if is_state(bat.switch, 'on') %}
                    {% set batteries_currently_on = batteries_currently_on + [bat.name] %}
                  {% endif %}
                {% endfor %}
                {% if current_soc <= (reference_soc - 2) and batteries_currently_on | length <= 1 %}
                  {% set blocked_batteries = blocked_batteries + [battery.name + '(BLOCKED - last battery)'] %}
                {% endif %}
              {% endfor %}
              {% if blocked_batteries | length > 0 %}
                BLOCKED: {{ blocked_batteries | join(', ') }}
              {% else %}
                None
              {% endif %}
            {% endif %}
          level: info

      # Log which batteries are marked for turn on
      - service: system_log.write
        data:
          message: >
            Batteries marked for turn ON (SOC >= {{ highest_soc }}%): 
            {% if batteries_to_turn_on | length > 0 %}
              {% for battery in batteries_to_turn_on %}{{ battery.name }}={{ battery.soc }}%{% if not loop.last %}, {% endif %}{% endfor %}
            {% else %}
              None
            {% endif %}
          level: info

      # Log detailed decision making for each battery with peak SOC tracking
      - repeat:
          for_each: "{{ valid_batteries }}"
          sequence:
            - variables:
                battery_soc: "{{ states(repeat.item.soc) | float }}"
                battery_switch_state: "{{ states(repeat.item.switch) | string }}"
                battery_peak_entity: "input_number.battery_{{ repeat.item.name }}_peak_soc"
                battery_peak_soc: "{{ states('input_number.battery_' + repeat.item.name + '_peak_soc') | float(0) }}"
                battery_initial_peak: >
                  {% set stored_peak = states('input_number.battery_' + repeat.item.name + '_peak_soc') | float(0) %}
                  {{ highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak }}
                reference_soc_for_turnoff: >
                  {% set current_soc = states(repeat.item.soc) | float %}
                  {% set stored_peak = states('input_number.battery_' + repeat.item.name + '_peak_soc') | float(0) %}
                  {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
                  {{ initial_peak }}
                is_in_turnoff_list: >
                  {% set ns = namespace(found=false) %}
                  {% for battery in batteries_to_turn_off %}
                    {% if battery.name == repeat.item.name %}
                      {% set ns.found = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.found }}
                is_in_turnon_list: >
                  {% set ns = namespace(found=false) %}
                  {% for battery in batteries_to_turn_on %}
                    {% if battery.name == repeat.item.name %}
                      {% set ns.found = true %}
                    {% endif %}
                  {% endfor %}
                  {{ ns.found }}
                planned_action: >
                  {% set soc = states(repeat.item.soc) | float %}
                  {% set ref_soc = reference_soc_for_turnoff | float %}
                  {% if soc <= (ref_soc - 2) %}
                    {% if is_state(repeat.item.switch, 'on') %}
                      TURN_OFF
                    {% else %}
                      ALREADY_OFF
                    {% endif %}
                  {% elif soc >= highest_soc %}
                    {% if is_state(repeat.item.switch, 'off') %}
                      TURN_ON
                    {% else %}
                      KEEP_ON
                    {% endif %}
                  {% else %}
                    {% if is_state(repeat.item.switch, 'on') %}
                      KEEP_ON
                    {% else %}
                      KEEP_OFF
                    {% endif %}
                  {% endif %}
                decision_reason: >
                  {% set soc = states(repeat.item.soc) | float %}
                  {% set ref_soc = reference_soc_for_turnoff | float %}
                  {% set stored_peak = states('input_number.battery_' + repeat.item.name + '_peak_soc') | float(0) %}
                  {% set initial_peak = highest_soc if (stored_peak == 0 or automation_just_started) else stored_peak %}
                  {% if soc <= (ref_soc - 2) %}
                    {% if stored_peak == 0 %}
                      "SOC {{ soc }}% <= {{ ref_soc - 2 }}% (initialized peak {{ initial_peak }}% - 2) - should be OFF"
                    {% elif automation_just_started %}
                      "SOC {{ soc }}% <= {{ ref_soc - 2 }}% (reset peak {{ initial_peak }}% - 2) - should be OFF"
                    {% else %}
                      "SOC {{ soc }}% <= {{ ref_soc - 2 }}% (stored peak {{ initial_peak }}% - 2) - should be OFF"
                    {% endif %}
                  {% elif soc >= highest_soc %}
                    "SOC {{ soc }}% >= {{ highest_soc }}% (current highest) - should be ON"
                  {% else %}
                    "SOC {{ soc }}% is between {{ ref_soc - 2 }}% and {{ highest_soc }}% - no change"
                  {% endif %}
            - service: system_log.write
              data:
                message: >
                  Battery {{ repeat.item.name }}: SOC={{ battery_soc }}%, Peak={{ battery_initial_peak }}%, RefSOC={{ reference_soc_for_turnoff }}%,
                  Switch={{ battery_switch_state }}, 
                  InTurnOffList={{ is_in_turnoff_list }}, 
                  InTurnOnList={{ is_in_turnon_list }},
                  PlannedAction={{ planned_action }}, 
                  Reason={{ decision_reason }}
                level: info

      # Skip battery management if we don't have enough valid batteries
      - condition: template
        value_template: "{{ valid_batteries | length >= 3 }}"

      # Check if any battery is currently charging (current > 0)
      - variables:
          any_battery_charging: >
            {% set ns = namespace(active=false) %}
            {% for battery in valid_batteries %}
              {% set current_val = states(battery.current) | float(0) %}
              {% if current_val > 0 %}
                {% set ns.active = true %}
              {% endif %}
            {% endfor %}
            {{ ns.active }}

      # Log if we're skipping turn-off logic due to active charging
      - choose:
          - conditions:
              - condition: template
                value_template: "{{ any_battery_charging }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: Skipping turn-off logic - at least one battery is actively charging (current > 0)"
                  level: warning
        default:
          # Only proceed with turn-off logic if no batteries are charging
          - service: system_log.write
            data:
              message: "Battery Protection: No batteries currently charging - proceeding with battery management logic"
              level: info

          # Turn off discharging for batteries with SOC <= highest_soc - 2
          - service: system_log.write
            data:
              message: "Battery Protection: DEBUG - batteries_to_turn_off list has {{ batteries_to_turn_off | length }} batteries: {{ batteries_to_turn_off | map(attribute='name') | list | join(', ') }}"
              level: warning
          - repeat:
              for_each: "{{ batteries_to_turn_off }}"
              sequence:
                - service: system_log.write
                  data:
                    message: "Battery Protection: DEBUG - Processing {{ repeat.item.name }} for TURN OFF (SOC: {{ repeat.item.soc }}%, Switch: {{ states(repeat.item.switch) }}, Switch Entity: {{ repeat.item.switch }})"
                    level: warning
                - service: system_log.write
                  data:
                    message: "Battery Protection: DEBUG - Conditions for {{ repeat.item.name }}: is_state='{{ is_state(repeat.item.switch, 'on') }}', soc_valid='{{ repeat.item.soc | string | is_number }}', soc_not_unavailable='{{ repeat.item.soc | string not in ['unavailable', 'unknown'] }}'"
                    level: warning
                - choose:
                    - conditions:
                        - condition: and
                          conditions:
                            - condition: template
                              value_template: "{{ is_state(repeat.item.switch, 'on') }}"
                            - condition: template
                              value_template: >
                                {% set soc_val = repeat.item.soc | string %}
                                {{ soc_val | is_number and soc_val not in ['unavailable', 'unknown'] }}
                      sequence:
                        - service: system_log.write
                          data:
                            message: "Battery Protection: DEBUG - All conditions met for {{ repeat.item.name }}, executing turn off"
                            level: warning
                        - service: switch.turn_off
                          target:
                            entity_id: "{{ repeat.item.switch }}"
                        - service: system_log.write
                          data:
                            message: "Battery Protection: ✓ TURNED OFF discharging for {{ repeat.item.name }} (SOC: {{ repeat.item.soc | string }}%) - REASON: SOC <= {{ repeat.item.reference_soc - 2 }}% (reference {{ repeat.item.reference_soc }}% - 2, peak: {{ repeat.item.peak_soc }}%)"
                            level: warning
                  default:
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✗ IGNORED turn OFF for {{ repeat.item.name }} - REASON: Conditions not met (switch_state={{ states(repeat.item.switch) }}, is_on={{ is_state(repeat.item.switch, 'on') }})"
                        level: warning

          # Turn on discharging for batteries with SOC >= highest_soc
          - repeat:
              for_each: "{{ batteries_to_turn_on }}"
              sequence:
                - service: system_log.write
                  data:
                    message: "Battery Protection: Processing {{ repeat.item.name }} for TURN ON (SOC: {{ repeat.item.soc }}%, Switch: {{ states(repeat.item.switch) }})"
                    level: info
                - choose:
                    - conditions:
                        - condition: and
                          conditions:
                            - condition: template
                              value_template: "{{ is_state(repeat.item.switch, 'off') }}"
                            - condition: template
                              value_template: >
                                {% set soc_val = repeat.item.soc | string %}
                                {{ soc_val | is_number and soc_val not in ['unavailable', 'unknown'] }}
                      sequence:
                        - service: switch.turn_on
                          target:
                            entity_id: "{{ repeat.item.switch }}"
                        - service: system_log.write
                          data:
                            message: "Battery Protection: ✓ TURNED ON discharging for {{ repeat.item.name }} (SOC: {{ repeat.item.soc | string }}%) - REASON: SOC >= {{ highest_soc }}% (highest)"
                            level: warning
                  default:
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✗ IGNORED turn ON for {{ repeat.item.name }} - REASON: Conditions not met"
                        level: info

      # Enhanced battery charging management with balancing detection to prevent oscillation
      - variables:
          any_battery_charging_for_switch_management: >
            {% set ns = namespace(active=false) %}
            {% for battery in valid_batteries %}
              {% set current_val = states(battery.current) | float(0) %}
              {% if current_val > 0 %}
                {% set ns.active = true %}
              {% endif %}
            {% endfor %}
            {{ ns.active }}
          
          battery_balancing_active: >
            {% set ns = namespace(charging=0, discharging=0) %}
            {% for battery in valid_batteries %}
              {% set current = states(battery.current) | float(0) %}
              {% if current > 0.5 %}
                {% set ns.charging = ns.charging + 1 %}
              {% elif current < -0.5 %}
                {% set ns.discharging = ns.discharging + 1 %}
              {% endif %}
            {% endfor %}
            {% set solar_power = states('sensor.solar_pv_combine') | float(0) - (states('sensor.solar_inverter_current_consumption') | float(0) + states('sensor.solar_ac_input_current_consumption') | float(0)) %}
            {{ ns.charging > 0 and ns.discharging > 0 and solar_power < 10 }}
          
          external_charging_active: >
            {% set solar_power = states('sensor.solar_pv_combine') | float(0) - (states('sensor.solar_inverter_current_consumption') | float(0) + states('sensor.solar_ac_input_current_consumption') | float(0)) %}
            {{ any_battery_charging_for_switch_management and solar_power >= 100 }}
          
          soc_spread: >
            {% set ns = namespace(soc_values=[]) %}
            {% for battery in valid_batteries %}
              {% set soc_val = states(battery.soc) | float(0) %}
              {% set ns.soc_values = ns.soc_values + [soc_val] %}
            {% endfor %}
            {% if ns.soc_values | length > 0 %}
              {{ (ns.soc_values | max) - (ns.soc_values | min) }}
            {% else %}
              0
            {% endif %}

      - choose:
          # External charging detected (solar power >= 100W) - turn on all batteries
          - conditions:
              - condition: template
                value_template: "{{ external_charging_active }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: External charging detected (solar power: {{ states('sensor.solar_pv_combine') | float(0) - (states('sensor.solar_inverter_current_consumption') | float(0) + states('sensor.solar_ac_input_current_consumption') | float(0)) }}W). Turning ON all batteries."
                  level: warning
              - repeat:
                  for_each: "{{ valid_batteries }}"
                  sequence:
                    - condition: template
                      value_template: "{{ is_state(repeat.item.switch, 'off') }}"
                    - service: switch.turn_on
                      target:
                        entity_id: "{{ repeat.item.switch }}"
                    - service: system_log.write
                      data:
                        message: "Battery Protection: ✓ TURNED ON {{ repeat.item.name }} - external charging detected"
                        level: warning

          # Battery balancing detected - maintain current state to prevent oscillation
          - conditions:
              - condition: template
                value_template: "{{ battery_balancing_active }}"
            sequence:
              - service: system_log.write
                data:
                  message: "Battery Protection: Battery balancing detected (SOC spread: {{ soc_spread }}%, solar power: {{ states('sensor.solar_pv_combine') | float(0) - (states('sensor.solar_inverter_current_consumption') | float(0) + states('sensor.solar_ac_input_current_consumption') | float(0)) }}W). Maintaining current switch states to prevent oscillation."
                  level: warning

      # Solar inverter management based on average SOC (only if we have valid data)
      - choose:
          # Turn off solar inverter if average SOC <= 40% and inverter is on
          - conditions:
              - condition: template
                value_template: "{{ average_soc > 0 and average_soc <= 40 and valid_batteries | length >= 3 }}"
              - condition: state
                entity_id: switch.solar_inverter
                state: "on"
            sequence:
              - service: switch.turn_off
                target:
                  entity_id: switch.solar_inverter
              - service: system_log.write
                data:
                  message: "Battery Protection: Turned OFF solar inverter (Average SOC: {{ average_soc }}%)"
                  level: warning
          
          # Turn on solar inverter if average SOC >= 50% and inverter is off
          - conditions:
              - condition: template
                value_template: "{{ average_soc >= 50 and valid_batteries | length >= 3 }}"
              - condition: state
                entity_id: switch.solar_inverter
                state: "off"
            sequence:
              - service: switch.turn_on
                target:
                  entity_id: switch.solar_inverter
              - service: system_log.write
                data:
                  message: "Battery Protection: Turned ON solar inverter (Average SOC: {{ average_soc }}%)"
                  level: info
        
        # Log when we skip inverter management due to insufficient data
        default:
          - condition: template
            value_template: "{{ valid_batteries | length < 3 }}"
          - service: system_log.write
            data:
              message: "Battery Protection: Skipping inverter management - insufficient valid battery data ({{ valid_batteries | length }}/{{ batteries | length }} batteries available)"
              level: warning

    mode: single
    max_exceeded: silent

# Battery startup monitoring automation
  - id: battery_startup_monitor
    alias: "Battery Startup Monitor"
    description: "Monitors battery availability during startup and sends notifications"
    trigger:
      - platform: homeassistant
        event: start
      - platform: time_pattern
        minutes: "/5"  # Check every 5 minutes
    condition:
      # Only run if we have insufficient batteries (removed uptime dependency)
      - condition: template
        value_template: >
          {% set ns = namespace(valid_count=0) %}
          {% for state in states.sensor %}
            {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
              {% set state_val = state.state | string %}
              {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                {% set ns.valid_count = ns.valid_count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.valid_count < 3 }}
    action:
      - variables:
          battery_status: >
            {% set ns = namespace(status=[]) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set battery_name = state.entity_id | regex_replace('^sensor\.dadski_battery_([a-z][0-9]+)_soc$', '\\1') %}
                {% set state_val = state.state | string %}
                {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                  {% set ns.status = ns.status + [battery_name + ': ' + state_val + '%'] %}
                {% else %}
                  {% set ns.status = ns.status + [battery_name + ': ' + state_val] %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.status | join(', ') }}
          
          available_count: >
            {% set ns = namespace(valid_count=0) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set state_val = state.state | string %}
                {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                  {% set ns.valid_count = ns.valid_count + 1 %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.valid_count }}
          
          total_batteries: >
            {% set ns = namespace(total_count=0) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set ns.total_count = ns.total_count + 1 %}
              {% endif %}
            {% endfor %}
            {{ ns.total_count }}

      - service: system_log.write
        data:
          message: "Battery Startup Monitor: {{ available_count }}/{{ total_batteries }} batteries available. Status: {{ battery_status }}"
          level: info

      - condition: template
        value_template: "{{ available_count < 3 }}"
      
      - service: notify.persistent_notification
        data:
          title: "Battery System Status"
          message: "Only {{ available_count }}/{{ total_batteries }} batteries are currently available. Battery protection is paused until at least 3 batteries are online. Status: {{ battery_status }}"
          notification_id: "battery_startup_status"

    mode: single
    max_exceeded: silent

# Peak SOC Reset Automation
  - id: battery_peak_soc_reset
    alias: "Battery Peak SOC Reset"
    description: "Resets stored peak SOC values when batteries reach full charge or when manually triggered"
    trigger:
      # Reset when any battery reaches 98% or higher (near full charge)
      - platform: numeric_state
        entity_id: 
          - sensor.dadski_battery_a1_soc
          - sensor.dadski_battery_a2_soc
          - sensor.dadski_battery_a3_soc
          - sensor.dadski_battery_a4_soc
          - sensor.dadski_battery_b1_soc
          - sensor.dadski_battery_b2_soc
          - sensor.dadski_battery_b3_soc
          - sensor.dadski_battery_b4_soc
        above: 98
      # Manual reset trigger (can be called via service)
      - platform: event
        event_type: battery_peak_soc_reset
    condition:
      # Only reset if we have sufficient battery data
      - condition: template
        value_template: >
          {% set ns = namespace(valid_count=0) %}
          {% for state in states.sensor %}
            {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
              {% set state_val = state.state | string %}
              {% if state_val | is_number and state_val not in ['unavailable', 'unknown'] %}
                {% set ns.valid_count = ns.valid_count + 1 %}
              {% endif %}
            {% endif %}
          {% endfor %}
          {{ ns.valid_count >= 3 }}
    action:
      - variables:
          # Get all batteries that need peak SOC reset
          batteries_to_reset: >
            {% set ns = namespace(battery_list=[]) %}
            {% for state in states.sensor %}
              {% if state.entity_id | regex_match('^sensor\.dadski_battery_[a-z][0-9]+_soc$') %}
                {% set battery_id = state.entity_id | regex_replace('^sensor\.dadski_battery_([a-z][0-9]+)_soc$', '\\1') %}
                {% set current_soc = state.state | float(0) %}
                {% set peak_entity = 'input_number.battery_' + battery_id + '_peak_soc' %}
                {% set stored_peak = states(peak_entity) | float(0) %}
                {% if current_soc >= 98 or stored_peak > 0 %}
                  {% set ns.battery_list = ns.battery_list + [{'name': battery_id, 'current_soc': current_soc, 'stored_peak': stored_peak, 'entity': peak_entity}] %}
                {% endif %}
              {% endif %}
            {% endfor %}
            {{ ns.battery_list }}

      - service: system_log.write
        data:
          message: "Battery Peak SOC Reset: Resetting peak SOC values for {{ batteries_to_reset | length }} batteries due to full charge or manual trigger"
          level: warning

      # Reset all peak SOC values to current SOC
      - repeat:
          for_each: "{{ batteries_to_reset }}"
          sequence:
            - service: input_number.set_value
              target:
                entity_id: "{{ repeat.item.entity }}"
              data:
                value: "{{ repeat.item.current_soc }}"
            - service: system_log.write
              data:
                message: "Battery Peak SOC Reset: Reset {{ repeat.item.name }} peak SOC from {{ repeat.item.stored_peak }}% to {{ repeat.item.current_soc }}%"
                level: info

    mode: single
    max_exceeded: silent
